## 1. 地址空间

### 1.1. 物理地址空间
为了更好的管理内存，操作系统将内存的的每个字节编址，形成了物理地址空间。
这个空间最大就是内存的大小

### 1.2. 虚拟地址空间
为了解决内存不够用的问题，操作系统的虚拟内存技术将所有的存储设备的每个字节编址，形成了虚拟地址空间，这也是进程看到的逻辑地址空间
这个地址空间理论上可以达到`2^CPU位数-1`，当然实际范围则是`MIN(内存+外存容量之和, 2^CPU位数-1)`


## 2. 存储管理

就是**进程逻辑地址空间**和**实际的物理地址空间**按什么单位划分，才能更好管理

## 3. 页式存储管理
将进程逻辑空间分成若干**等大小的页面**，将物理内存空间分成同**等页面大小的物理块**，以页面为单位把进程的页面装进物理内存中的页面中

### 3.1. 页面
进程逻辑空间的页面过大的话难以找到合适的内存块分配，过小的话会产生内存碎片，通常是512B-8K。

### 3.2. 页表
我们需要知道进程的页面分配到内存的哪块页面上，页面用来记录物理空间和逻辑空间的映射关系
![](https://raw.githubusercontent.com/TDoct/images/master/img/20200208152833.png)
如上图，就是把进程逻辑空间中的页面1映射到物理内存的第1个块


### 3.3. 问题
如果有一段连续的逻辑分布在多个页面中，将大大降低执行效率

## 4. 段式存储管理

将进程逻辑空间分成若干**非等大小的段**（段的大小由连续逻辑的大小决定），将物理内存空间分成同**等段大小的物理块**，以段为单位把进程的段装进物理内存中的段中

### 4.1. 段表
![](https://raw.githubusercontent.com/TDoct/images/master/img/20200208151905.png)
如上图，把进程逻辑地址空间的段1映射到物理内存基址为10K，段长为30K的地方

### 4.2. 问题
会产生内存碎片

### 4.3. 段 VS 页

|           |         页          |           段           |
| --------- | ------------------ | ---------------------- |
| 单位       | 物理单位            | 逻辑单位                |
| 目的       | 为了更好的管理物理内存 | 为了更好的适应进程的需求 |
| 页、段大小 | 页大小由硬件决定     | 段长度可以动态变化       |
| 页、段表   | 页表信息是一维的     | 段表信息是二维的        |

## 5. 段页式存储管理
综合了页和段的优点，页可以有效提高内存利用率，段可以更好满足用户需求

先将逻辑空间按段式管理分成若干**非等大小的段**，再把段内空间按页式管理分成**若干等大小的页**，将物理内存空间分成同**等页面大小的物理块**，以页面为单位把进程的页面装进物理内存中的页面中
![](https://raw.githubusercontent.com/TDoct/images/master/img/20200208153443.png)

## 6. 参考
- [搞定操作系统面试，看这篇就够了（一） \- 掘金](https://juejin.im/post/5cb048b9e51d456e5d3dac09)
- [搞定操作系统面试，看这篇就够了（二） \- 掘金](https://juejin.im/post/5cb048f0e51d456e3428c0cd)