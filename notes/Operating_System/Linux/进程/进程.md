[toc]
 

## 1. 进程

进程可以看作一个执行中的程序
使用ps aux可以查看进程
使用fork调用可以创建一个新的进程。创建出来的child进程和parent进程共享所有的segment：如text、stack、heap等，当child进程修改stack或heap的时候才会复制独有的一份stack和heap

### 1.1. 僵尸进程
父进程fork了一个子进程，子进程先exit，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这个子进程就成了僵尸进程

### 1.2. 孤儿进程
一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。



## 3. 轻量级进程

LWP和线程其实是同一个概念。前者指用在kernel level，后者用在user level
LWP与传统进程的区别在于前者共享了地址空间和一些资源（如open files）


## 4. 进程的内存布局

![](https://raw.githubusercontent.com/TDoct/images/master/1598196545_20200823232618187_24400.png)

### 4.1. 代码区
- 包括能被CPU执行的机器代码（指令）和只读数据比如字符串常量
- 程序一旦加载完成代码区的大小就不会再变化了。

### 4.2. 数据区
- 包括程序的全局变量和静态变量（c语言有静态变量，而go没有）
- 程序加载完毕后数据区的大小也不会发生改变。

### 4.3. 堆
- 程序运行时动态分配的内存都位于堆中，这部分内存由内存分配器负责管理。
- 该区域的大小会随着程序的运行而变化，即当我们向堆请求分配内存但分配器发现堆中的内存不足时，它会向操作系统内核申请向高地址方向扩展堆的大小，而当我们释放内存把它归还给堆时如果内存分配器发现剩余空闲内存太多则又会向操作系统请求向低地址方向收缩堆的大小

### 4.4. 栈
- 又叫函数调用栈。每调用一个函数都会push一个栈帧，调用完成pop这个栈帧
- 用来保存函数的局部变量；向被调用函数传递参数；返回函数的返回值；保存函数的返回地址
- 栈的大小就会随函数调用层级的增加而生长，随函数的返回而缩小
#### 4.4.1. 调用举例
- A()->B()->C()
![](https://raw.githubusercontent.com/TDoct/images/master/1598197272_20200823234002789_13139.png)

- B、C执行完毕
![](https://raw.githubusercontent.com/TDoct/images/master/1598197275_20200823234008260_3459.png)


## 5. 如何优雅的关闭进程
- 思路
    - 服务端启动时多开启一个协程用来监听关闭信号
    - 当协程接收到关闭信号时，将拒绝接收新的连接，并处理好当前所有连接后断开
    - 启动一个新的服务端进程来接管新的连接
    - 关闭当前进程
- 举例
    - 踢掉L5流量，保证新连接不会过来
    - 等待当前连接都处理完后发送一个关闭信号到channel中，接收到关闭信号就关闭服务
    - 重启服务
    - 加上L5流量
## 6. 参考

- [What are Linux Processes, Threads, Light Weight Processes, and Process State](https://www.thegeekstuff.com/2013/11/linux-process-and-threads/)
- [Linux下调用pthread库创建的线程是属于用户级线程还是内核级线程？求大神指教? \- 知乎](https://www.zhihu.com/question/35128513)
- [go语言调度器源代码情景分析之四：函数调用栈 \- 爱写程序的阿波张 \- 博客园](https://www.cnblogs.com/abozhang/p/10769346.html)
- [golang程序优雅关闭与重启 \- 知乎](https://zhuanlan.zhihu.com/p/42061521)