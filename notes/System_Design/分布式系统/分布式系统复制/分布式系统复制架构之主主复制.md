## 1. 什么是Leader-Leader
- 有多个Leader，每个Leader有多个Follwer

## 2. Leader-Leader使用场景
- 多个数据中心
- 应用程序在断网之后仍然需要继续工作
## 3. Leader-Leader原理
### 3.1. Leader选举
### 3.2. Leader同步数据给Leader
- 写入数据的时候交由Leader处理，Leader保存到本地之后有两个操作
    - 一个是把数据变更发送给本数据中心的Follower，Follower重放数据变更
    - 另一个是发送给其他数据中心的Leader，Leader重放数据变更并同步给Follower
#### 3.2.1. 写入冲突问题
- 多个客户端同时修改了同一个key
    - 在单leader的情况下，第二个写入将会阻塞等待第一个写入完成
    - 多leader的情况下，写入数据中心1的leader之后，数据是通过异步复制到另一个数据中心的leader，所以两个写入都是成功的
##### 3.2.1.1. 如何解决写入冲突问题
###### 3.2.1.1.1. 同步等待
- 客户端请求leader1写入，leader1同步给其他leader之后再返回给客户端成功
- 缺点：同步复制可用性低（性能低）
###### 3.2.1.1.2. 避免冲突
- 同一个用户的写入路由到同一个leader
- 缺点：如果路由改变那么还是会发生冲突
###### 3.2.1.1.3. 解决冲突
- LWW：
    - 给每个写入分配为一个时间戳，时间戳高的写入，丢弃其他写入
    - 一般都是服务器端给每条记录增加一个version字段，客户端先读取数据，修改的时候version+1，服务器检查客户端的version是否大于数据的version，是则修改，否则拒绝
- 将这些值合并在一起
- 自定义解决
    - 写时执行：一旦检测到写入有冲突，就会调用冲突处理程序处理
    - 读时执行：当检测到冲突时，所有冲突写入被存储。下一次读取数据时，会将这些多个版本的数据返回给应用程序。应用程序可能会提示用户或自动解决冲突，并将结果写回数据库

### 3.3. 故障处理