## 1. 什么是Leaderness
- 没有leader，客户端写的时候将写请求并行发给所有replica，读的时候同样将读请求并行发给所有replica
## 2. Leaderness使用场景
## 3. Leaderness原理
### 3.1. 数据同步
#### 3.1.1. 写入冲突问题
- 允许多个客户端同时写入相同的key，这说明会有并发问题。
- 跟Leader-Leader情况是一样可以使用LWW，需要改进下：不仅是每个key增加version，还需要对每个副本增加version
### 3.2. 故障处理
- 假设有三个replica，两个用户
- 用户1写入replica1、replica2、replica3
    - replica1成功，replica2成功，replica3失败
- 用户2从replica3读取，读到的是旧数据
#### 3.2.1. Quorum一致性
- 法定写入，法定读取
    - 写请求并行发给多个节点，法定节点写入成功就成功
    - 读请求并行发给多个节点，法定节点返回成功后取最新版本号的数据
##### 3.2.1.1. Quorum如何确定
- 假设总共有n个replica，每个写入需要w个节点确认才算成功，每个读取需要r个节点返回才算成功，那么`w+r>n`
##### 3.2.1.2. Quorum的局限性
#### 3.2.2. 宕机的节点重启了怎么修复数据
##### 3.2.2.1. 读修复
- 并行读取后，把新版本的数据覆盖到旧版本
##### 3.2.2.2. 反熵
- 后台进程扫描修复
