[toc]
 


## 1. 2PC是什么
保证强一致性的一种分布式事务方案

## 2. 2PC流程
- 把事务分成两个阶段
    - 第一阶段：由事务管理器向所有database发送prepare请求
    - 第二阶段根据第一阶段的结果决定。
        - 如果第一阶段全部响应ok那么执行第二阶段的commit；
        - 如果第一阶段有一个database响应fail或者事务管理器等待超时那么执行第二阶段的rollback
- ![2PC](https://raw.githubusercontent.com/TDoct/images/master/1622646866_20210602231422247_15205.png)





## 3. 2PC的使用场景

- 适用于强一致性、时间敏感度高、分布式事务可以回滚的业务的处理结果，比如金融转账场景
- 单个服务多个数据源且数据源都是DB，即传统单体
## 4. 2PC的问题

- 性能问题：在阶段1，各个database开始锁定资源，直到第二阶段才释放锁资源。这段期间一直处于同步阻塞状态，性能很差
- 单点问题：阶段1完成之后，在阶段2如果事务管理器挂了，那么所有database无法收到下一步指令，事务无法继续执行
- 一致性问题：阶段1完成之后，在阶段2如果任一database挂了没有返回ACK，那么其他database是提交还是回滚无法确定
## 5. 2PC的实现
- 每个参与者需要实现3个接口
    - Prepare
    - Commit
    - Rollback
### 5.1. XA
- 数据库基于2PC实现的分布式事务，有一个统一标准叫做DTP
- DTP模型定义了几个角色：
    - AP：我们的微服务
    - TM：全局事务管理者
    - RM：数据库
    - CRM：TM和RM的通信中间件
- 在该模型中，一个分布式事务（全局事务）可以被拆分成许多个本地事务，运行在不同的AP和RM上。每个本地事务的ACID很好实现，但是全局事务必须保证其中包含的每一个本地事务都能同时成功，若有一个本地事务失败，则所有其它事务都必须回滚。但问题是，本地事务处理过程中，并不知道其它事务的运行状态。因此，就需要通过CRM来通知各个本地事务，同步事务执行的状态。
- 为了让不同的数据库之间可以通讯，必须有一个标准，因此有了XA。XA就是TM和RM通讯的接口规范
### 5.2. Seata的XA模式

- 支持XA事务的数据库。
- Java 应用，通过 JDBC 访问数据库。


## 6. 参考
- [再有人问你分布式事务，把这篇扔给他 \- 掘金](https://juejin.im/post/5b5a0bf9f265da0f6523913b#heading-15)
- [事务 \- 请问TCC和2PC的区别在哪里 \- SegmentFault 思否](https://segmentfault.com/q/1010000015277647)
- [请问TCC和2PC的区别在哪里？ \- 知乎](https://www.zhihu.com/question/280888550)
- [Seata XA 模式](http://seata.io/zh-cn/docs/dev/mode/xa-mode.html)