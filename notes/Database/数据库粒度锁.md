## 1. 什么是粒度锁
- 数据库的锁按照粒度划分，可以分成行锁、页锁、表锁

## 2. 行锁

### 2.1. 是什么
行锁就是按照行的粒度对数据进行锁定

### 2.2. 分类
- 再按读写划分
    - 共享锁：读锁，S（Share）锁。读取一条记录时，先获取该锁。多个读操作可以同时进行，但会阻塞写
    - 独占锁：写锁，X（Exclusive）锁。修改一条记录时，先获取该锁。当前写操作没有完成前，会阻塞其他写和读操作

- 兼容性

    | 兼容性 |  读锁  |  读锁  |
    | ------ | ------ | ------ |
    | 读锁   | 兼容   | 不兼容 |
    | 读锁   | 不兼容 | 不兼容 |

- 使用
    - 共享锁：`SELECT ... LOCK IN SHARE MODE`
    - 独占锁：`SELECT ... FOR UPDATE`
## 3. 页锁
### 3.1. 是什么
- 页锁就是在页的粒度上进行锁定

## 4. 表锁

### 4.1. 是什么
- 表锁就是对数据表进行锁定
### 4.2. 分类
- 再按读写划分
    - 如果一个事务给表加了共享锁 ，那么：
        - 别的事务可以继续获得该**表**的 S锁
        - 别的事务可以继续获得该**表中的某些记录**的 S锁
        - 别的事务不可以继续获得该**表**的 X锁
        - 别的事务不可以继续获得该**表中的某些记录**的 X锁
    - 如果一个事务给表加了独占锁 （意味着该事务要独占这个表），那么：
        - 别的事务不可以继续获得该**表**的 S锁
        - 别的事务不可以继续获得该**表中的某些记录**的 S锁
        - 别的事务不可以继续获得该**表**的 X锁
        - 别的事务不可以继续获得该**表中的某些记录**的 X锁

- 有个问题：如果事务A在记录上加了S锁，然后事务B想加个表级别的X锁，需要先判断所有记录有没有加了S或者X锁，如果遍历的话效率太低了。因此事务A在加记录级别的S锁时，需要在表级别加个IS锁，仅用于其他事务加速判断
    - 意向共享锁，Intention Shared Lock ，简称 IS锁 。当事务准备在**某条记录**上加 S锁 时，需要先在**表级别**加一个 IS锁 。
    - 意向独占锁， Intention Exclusive Lock ，简称 IX锁 。当事务准备在**某条记录**上加 X锁 时，需要先在**表级别**加一个 IX锁
- 兼容性


| 兼容性 |   X    |   IX   |   S    |   IS   |
| ------ | ------ | ------ | ------ | ------ |
| X      | 不兼容 | 不兼容 | 不兼容 | 不兼容 |
| IX     | 不兼容 | 兼容   | 不兼容 | 兼容   |
| S      | 不兼容 | 不兼容 | 兼容   | 兼容   |
| IS     | 不兼容 | 兼容   | 兼容   | 兼容   |

## 5. 元数据锁
### 5.1. 是什么
表的结构这种属于表的元数据，元数据锁就是对表的结构加的锁
也是为了解决并发问题，比如A事务select数据准备修改，然后B事务alter了表结构并提交，A事务update但由于表结构变了，报错
### 5.2. 分类
执行DDL的时候会加写锁，执行DML的时候会加读锁
## 6. 行锁 vs 页锁 vs 表锁

|       | 行锁 | 页锁 | 表锁 |
| ----- | --- | --- | --- |
| 粒度   | 小   | 中   | 大   |
| 锁冲突 | 高   | 中   | 低   |
| 并发度 | 高   | 中   | 低   |
| 死锁   | 高   | 中   | 低   |


## 7. 参考
- [深入理解MDL元数据锁 \- SegmentFault 思否](https://segmentfault.com/a/1190000021212804)