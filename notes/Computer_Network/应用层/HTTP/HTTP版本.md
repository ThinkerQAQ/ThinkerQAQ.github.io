[toc]


## 1. HTTP1.0

### 1.1. 客户端/服务器

### 1.2. 短链接

- 每次HTTP请求时建立TCP连接、请求完释放TCP连接，以尽快将资源释放出来服务其他客户端
- 问题：对于图片这种静态资源每张都需要请求服务器，重新建立连接的时间很浪费
    - 解决：`Connection：Keep-Alive`。即请求完不释放链接，继续保持

### 1.3. 无状态

- http是无状态的协议，即对于事务处理没有记忆能力，换句话说就是每个请求都是独立且完整的，上一个请求和后一个请求之间没有关系，也无法相互感知到
- 好处：水平扩展性好
- 问题：我们有这样的需求，需要知道多个请求是否由同一个用户发出的
    - 解决：[cookie和session.md](cookie和session.md)。但是每次请求都得带上重复的数据，所以性能降低




## 2. HTTP1.1
### 2.1. 长连接
- 多个HTTP请求复用一个TCP连接。只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求
- 问题：短链接场景下连接关闭就是请求处理结束了，长连接的话怎么判断请求处理结束呢
    - 解决： `Content-Length：xxx`：这个字段可以告诉客户端HTTPResponse的Body共有多少个字节，客户端接收到这么多个字节之后，就知道响应成功接收完毕
        - 问题：动态内存不好计算长度
            - 解决：Chunk（Http Streaming）
                - `Transfer-Encoding：chunked`：目的是告诉客户端，响应的Body是分成了一块块的，块与块之间有间隔符，所有块的结尾也有个特殊标记。这样，即使没有 Content-Length 字段，也能方便客户端判断出响应的末尾
### 2.2. Pipeline
- 客户端可以同时发出多个HTTP请求，而不用一个个等待响应
- 问题：队头阻塞：客户端发出1、2、3请求，服务器并发处理返回，可能2、3响应回了客户端但是1还没有，此时客户端会阻塞等待1返回。所以默认是把Pipeline关闭的
### 2.3. 断点续传
- 实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。

## 3. HTTP/2
- ![](https://raw.githubusercontent.com/TDoct/images/master/1628931966_20210814165927687_30363.png)
### 3.1. 二进制分帧
- 把一个HTTP Request拆分成多个帧并发发送
### 3.2. 头部压缩
- 在HTTP 1.1里，对于报文的报文体，已经有相应的压缩，尤其对于图片，本来就是压缩过的；但对于报文的头部，一直没有做过压缩


## 4. 参考

- [HTTP 协议详解\_知识库\_博客园](https://kb.cnblogs.com/page/130970/)
- [深入解析 multipart/form\-data \- 简书](https://www.jianshu.com/p/29e38bcc8a1d)
- [HTTP 1\.1 版本新特性描述\_CNYYGJ\-CSDN博客](https://blog.csdn.net/CNYYGJ/article/details/53466059)

